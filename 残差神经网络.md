# 残差神经网络（ResNet）
> def shortcut(input, ch_out, stride, name):
    ch_in = input.shape[1]
    if ch_in != ch_out or stride != 1:
        return conv_bn_layer(input, ch_out, 1, stride, name=name)
    else:
        return input

def bottleneck_block(input, num_filters, stride, name):
    conv0 = conv_bn_layer(input=input,
                          num_filters=num_filters,
                          filter_size=1,
                          act='relu',
                          name=name + "_branch2a")
    conv1 = conv_bn_layer(input=conv0,
                          num_filters=num_filters,
                          filter_size=3,
                          stride=stride,
                          act='relu',
                          name=name + "_branch2b")
    conv2 = conv_bn_layer(input=conv1,
                          num_filters=num_filters * 4,
                          filter_size=1,
                          act=None,
                          name=name + "_branch2c")

    short = shortcut(input, num_filters * 4, stride, name=name + "_branch1")

    return fluid.layers.elementwise_add(x=short, y=conv2, act='relu', name=name + ".add.output.5")

depth = [3, 4, 6, 3]
num_filters = [64, 128, 256, 512]

conv = conv_bn_layer(input=input, num_filters=64, filter_size=7, stride=2, act='relu', name="conv1")
conv = fluid.layers.pool2d(input=conv, pool_size=3, pool_stride=2, pool_padding=1, pool_type='max')

for block in range(len(depth)):
    for i in range(depth[block]):
        conv_name = "res" + str(block + 2) + chr(97 + i)
        conv = bottleneck_block(input=conv,
                                num_filters=num_filters[block],
                                stride=2 if i == 0 and block != 0 else 1,
                                name=conv_name)

pool = fluid.layers.pool2d(input=conv, pool_size=7, pool_type='avg', global_pooling=True)
return pool
